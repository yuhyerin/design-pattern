1. 데코레이터 패턴?
- decorate(장식하다)라는 의미 -> 기존 내용에 무언가 덧붙인다는 의미가 강하다.
- 데코레이터 패턴은 객체에 계속해서 데코레이션을 추가하는 방식이다.

2. 구조
- "상속"을 통해 기능을 확장해 나간다면?
Display
    |
HeartDeco / StarDeco / DiaDeco / CircleDeco ...
    |
HeartAndStarDeco / HeartAndDiaDeco / StarAndDiaDeco / HeartAndCircleDeco ...
-> 여러개의 데코를 조합해서 적용하고 싶을때마다 클래스가 증가하고 구조가 점점 복잡해짐.

- 데코레이터 패턴은 상속이 아닌 "위임" 방식으로 기능을 확장해 나간다.
- 최상위 데코 인터페이스(or 추상클래스)를 만든다.
 특징1. 내부에 위임 대상을 필드에 갖고 있다. -> 위임 대상의 기능을 사용하되, 데코는 단지 그 기능에 부가적으로 꾸며주는 역할을 하는 것 뿐.
 특징2. 위임 대상을 상속한다. -> 데코 구현체가 위임 대상의 하위 타입이 될 수 있도록...
- 추가하고 싶은 데코가 있으면 최상위 데코 인터페이스(or 추상 클래스)를 확장하는 클래스를 만들어 부가 기능을 추가할 수 있다.

3. 장점
- 데코레이터를 "조합하는 방식"으로 기능을 확장할 수 있다.
- 확장하고자 하는 기능들이 별도의 클래스로 분리되기 때문에, 각 기능들이 서로 영향을 주지 않고 변경할 수 있는 구조가 된다.
- 단일책임원칙(SRP)을 지킬 수 있게 해준다.
- 즉, 기능 확장을 위한 유연한 구조를 제공한다.

4. 단점
- 지금은 데코 대상이 되는 Display 내부에 show() 메서드 하나뿐이라 데코레이터 구현이 비교적 간단했지만, 메서드가 증가하면 데코레이터 구현도 복잡해진다.
-> 그래서 데코레이터 대상이 되는 타입에 기능 갯수를 고려해야한다.
- 사용자 입장에선 데코레이터 객체와, 실제 구현 객체의 구분이 되지 않아서 코드만으로는 기능이 어떻게 동작하는지 이해하기 어렵다.
- 예를들어, 클라이언트 코드에 public void playDeco(Display display){ display.show(); } 이와같은 메서드가 존재한다고 할 때
인자로 넘어온 Display 가 FullBorder 만 추가된 Display 인지, CustomBorder 도 추가된 Display 인지 런타임에 생성된 객체 구조를 이해해야 알 수 있다.